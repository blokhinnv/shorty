//go:build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"html/template"
	"os"
	"path/filepath"
	"strings"
)

type templateLogger struct {
	Package string
	Funcs   []templateFunc
	Levels  []templateLevel
}

type templateFunc struct {
	Name string
	IsF  bool
}

type templateLevel struct {
	Name string
}

const templateStr = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by genlog.go

package {{.Package}}

import "github.com/sirupsen/logrus"

func SetLevel(level logrus.Level) {
	logrus.SetLevel(level)
}

const(
	{{range .Levels}}
	{{.Name}} logrus.Level = logrus.{{.Name}}
	{{end}}
)

{{range .Funcs}}
	{{if .IsF }}
	func {{.Name}}(format string, args ...interface{}) {
		logrus.{{.Name}}(format, args...)
	}
	{{else}}
	func {{.Name}}(args ...interface{}) {
		logrus.{{.Name}}(args...)
	}
	{{end}}

{{end}}
`

var tmpl = template.Must(template.New("log").Parse(templateStr))

func main() {
	flag.Parse()
	args := flag.Args()
	funcs := make([]templateFunc, 0, len(args))
	levels := make([]templateLevel, 0, len(args))
	for _, level := range args {
		funcs = append(funcs, templateFunc{Name: level})
		funcs = append(funcs, templateFunc{Name: fmt.Sprintf("%vf", level), IsF: true})
		funcs = append(funcs, templateFunc{Name: fmt.Sprintf("%vln", level)})
		if level != "Print" {
			levels = append(levels, templateLevel{Name: fmt.Sprintf("%vLevel", level)})
		}
	}
	// генерируем код по шаблону
	var buf bytes.Buffer
	err := tmpl.Execute(&buf, templateLogger{Package: "log", Funcs: funcs, Levels: levels})
	if err != nil {
		panic(err)
	}

	// форматируем код
	bufFmt, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	// записываем сгенерированный код в файл
	fname := os.Getenv("GOFILE") // имя файла, из которого вызван go:generate,
	basename := strings.TrimSuffix(fname, filepath.Ext(fname))
	err = os.WriteFile(fmt.Sprintf("%s_funcs.go", basename), bufFmt, 0644)
	if err != nil {
		panic(err)
	}
}
